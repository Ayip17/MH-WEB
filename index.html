<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Monster Hunter Prototype - Clean Structure</title>
<style>
/* ---- UI styling (sama persis visual) ---- */
body{margin:0;background:#2c3e50;display:flex;align-items:center;justify-content:center;min-height:100vh;font-family:Arial, sans-serif}
.game-container{position:relative;background:#34495e;padding:20px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.5);text-align:center}
canvas{display:block;margin:10px auto;border-radius:5px;border:3px solid #ecf0f1;background:#27ae60}
.ui-overlay{position:absolute;top:30px;left:30px;color:#ecf0f1;font-family:monospace;font-size:14px;pointer-events:none}
.health-bar,.dash-cooldown{background:#2c3e50;border:2px solid #ecf0f1;border-radius:10px;overflow:hidden}
.health-bar{width:200px;height:20px;margin-bottom:10px}
.health-fill{height:100%;background:linear-gradient(90deg,#e74c3c,#c0392b);transition:width .3s ease}
.dash-cooldown{width:150px;height:15px}
.dash-fill{height:100%;background:linear-gradient(90deg,#f39c12,#e67e22);transition:width .1s linear}
.controls{color:#ecf0f1;margin-top:15px}
.controls h3{margin:10px 0;color:#3498db}
.control-item{margin:5px 0;font-size:14px}
.stats{color:#ecf0f1;margin-top:15px;font-family:monospace;font-size:12px}
#menuScreen,#gameOverOverlay{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;flex-direction:column;border-radius:10px;z-index:20}
#menuScreen{background:rgba(44,62,80,.98);color:#fff}
#gameOverOverlay{background:rgba(44,62,80,.95);color:#fff;font-size:32px;display:none;z-index:30}
#messageLog{position:absolute;left:50%;top:30px;transform:translateX(-50%);min-width:300px;max-width:600px;pointer-events:none;z-index:25;text-align:center}
</style>
</head>
<body>
  <div id="gameOverOverlay">
    <div style="margin-top:120px">üíÄ GAME OVER üíÄ</div>
    <button id="restartBtn" style="margin-top:40px;font-size:22px;padding:12px 32px;border-radius:8px;border:none;background:#e74c3c;color:#fff;cursor:pointer">Restart</button>
  </div>

  <div class="game-container">
    <div id="messageLog"></div>

    <div id="menuScreen">
      <h1 style="font-size:2.5em;margin-bottom:20px">Monster Hunter Prototype</h1>
      <div style="font-size:1.2em;margin-bottom:30px">
        <div>üéØ <b>WASD / Arrow Keys</b>: Move Player</div>
        <div>üèÉ‚Äç‚ôÇÔ∏è <b>Spacebar</b>: Dash (I-Frames!)</div>
        <div>‚öîÔ∏è <b>Hold Mouse</b>: Attack towards cursor</div>
        <div>üõ°Ô∏è <b>Blue Slimes</b>: Have shields (2 hits to break!)</div>
        <div>üëë <b>Boss Slime</b>: Defeat for next stage!</div>
      </div>
      <button id="startGameBtn" style="font-size:1.5em;padding:16px 40px;border-radius:10px;border:none;background:#27ae60;color:#fff;cursor:pointer">Click to Start</button>
    </div>

    <canvas id="gameCanvas" width="1000" height="600"></canvas>

    <div class="ui-overlay">
      <div>‚ù§Ô∏è HUNTER HP: <span id="healthText">500/500</span></div>
  <div class="health-bar"><div class="health-fill" id="playerHealthFill"></div></div>
      <div>üèÉ‚Äç‚ôÇÔ∏è DASH READY</div>
      <div class="dash-cooldown"><div class="dash-fill" id="dashCooldownFill"></div></div>
    </div>

    <div class="controls">
      <h3>Complete Controls:</h3>
      <div class="control-item">üéØ WASD / Arrow Keys: Move Player</div>
      <div class="control-item">üèÉ‚Äç‚ôÇÔ∏è Spacebar: Dash with I-Frames!</div>
      <div class="control-item">‚öîÔ∏è Hold Mouse: Attack towards cursor</div>
      <div class="control-item">üõ°Ô∏è Blue Slimes: Have shields (2 hits to break!)</div>
    </div>

    <div class="stats" id="gameStats">Position: (0, 0) | Slimes: 0 | Status: Ready</div>
  </div>

<script>
/* =========================
   Clean-structured JS
   (Behavior = original code)
   ========================= */

/* ---------- Config / State ---------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let gameRunning = false;
let gameOver = false;
let stage = 1;
let gameTime = 0;

const screenShake = {
  intensity: 0,
  duration: 0,
  timer: 0,
  offsetX: 0,
  offsetY: 0
};

function startScreenShake(intensity, duration) {
  screenShake.intensity = intensity;
  screenShake.duration = duration;
  screenShake.timer = duration;
}

function updateScreenShake() {
  if (screenShake.timer > 0) {
    screenShake.timer -= 16;
    
    // Calculate shake strength (decreases over time)
    const shakeStrength = (screenShake.timer / screenShake.duration) * screenShake.intensity;
    
    // Generate random offset
    screenShake.offsetX = (Math.random() - 0.5) * shakeStrength;
    screenShake.offsetY = (Math.random() - 0.5) * shakeStrength;
  } else {
    // Reset when shake ends
    screenShake.offsetX = 0;
    screenShake.offsetY = 0;
  }
}

let lastFrame = performance.now();

/* Damage Numbers System */
const damageNumbers = [];

class DamageNumber {
  constructor(x, y, damage, color = '#ff0000') {
    this.x = x;
    this.y = y;
    this.damage = damage;
    this.color = color;
    this.life = 1000; // 1 second
    this.timer = 0;
    this.offsetY = 0;
    this.alpha = 1;
  }
  
  update() {
    this.timer += 16;
    this.offsetY -= 2; // Float upward
    this.alpha = 1 - (this.timer / this.life); // Fade out
    
    return this.timer >= this.life; // Return true when expired
  }
  
  render() {
    ctx.save();
    ctx.globalAlpha = this.alpha;
    ctx.fillStyle = this.color;
    ctx.font = 'bold 18px monospace';
    ctx.textAlign = 'center';
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    
    // Draw outline first
    ctx.strokeText(`-${this.damage}`, this.x, this.y + this.offsetY);
    // Draw fill
    ctx.fillText(`-${this.damage}`, this.x, this.y + this.offsetY);
    
    ctx.restore();
  }
}

function createDamageNumber(x, y, damage, color = '#ff0000') {
  damageNumbers.push(new DamageNumber(x, y, damage, color));
}

/* Hit Stop System */
const hitStop = {
  active: false,
  duration: 0,
  timer: 0
};

function startHitStop(duration) {
  hitStop.active = true;
  hitStop.duration = duration;
  hitStop.timer = duration;
}

function updateHitStop() {
  if (hitStop.active) {
    hitStop.timer -= 16;
    if (hitStop.timer <= 0) {
      hitStop.active = false;
    }
  }
}

/* Particle System */
const particles = [];

class Particle {
  constructor(x, y, vx, vy, color, size, life) {
    this.x = x;
    this.y = y;
    this.vx = vx; // velocity x
    this.vy = vy; // velocity y
    this.color = color;
    this.size = size;
    this.life = life;
    this.maxLife = life;
    this.alpha = 1;
    this.gravity = 0.2;
    this.friction = 0.98;
  }
  
  update() {
    // Apply velocity
    this.x += this.vx;
    this.y += this.vy;
    
    // Apply physics
    this.vy += this.gravity;
    this.vx *= this.friction;
    this.vy *= this.friction;
    
    // Fade out
    this.life -= 16;
    this.alpha = this.life / this.maxLife;
    
    // Shrink over time
    this.size *= 0.995;
    
    return this.life <= 0;
  }
  
  render() {
    ctx.save();
    ctx.globalAlpha = this.alpha;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// Particle creation helpers
function createBloodSplash(x, y, count = 8) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 2 + Math.random() * 4;
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed - 2; // Slight upward bias
    const size = 2 + Math.random() * 3;
    const life = 300 + Math.random() * 200;
    particles.push(new Particle(x, y, vx, vy, '#cc0000', size, life));
  }
}

function createImpactSparks(x, y, count = 6) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 3;
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;
    const size = 1 + Math.random() * 2;
    const life = 200 + Math.random() * 150;
    particles.push(new Particle(x, y, vx, vy, '#ffaa00', size, life));
  }
}

  /* Roguelike Upgrade Choice System */
  let upgradeMenuActive = false;
  const upgradeChoices = [];

  const upgradeTypes = {
    health: { name: 'Health Boost', desc: '+50 Max Health', color: '#e74c3c' },
    speed: { name: 'Speed Boost', desc: '+1 Movement Speed', color: '#2ecc71' },
    damage: { name: 'Damage Boost', desc: '+10 Attack Damage', color: '#f39c12' },
    multishot: { name: 'Multishot', desc: 'Fire Multiple Projectiles', color: '#9b59b6' },
    homing: { name: 'Homing Missiles', desc: 'Projectiles Track Enemies', color: '#1abc9c' },
    laser: { name: 'Piercing Laser', desc: 'Projectiles Pierce Through Enemies', color: '#f1c40f' },
    dashCooldown: { name: 'Dash Mastery', desc: 'Faster Dash Cooldown', color: '#3498db' },
    attackSpeed: { name: 'Rapid Fire', desc: 'Faster Attack Rate', color: '#e67e22' }
  };

  function generateUpgradeChoices() {
    upgradeChoices.length = 0;
    const availableUpgrades = Object.keys(upgradeTypes);
    
    // Generate 3 random unique choices
    while (upgradeChoices.length < 3) {
      const randomUpgrade = availableUpgrades[Math.floor(Math.random() * availableUpgrades.length)];
      if (!upgradeChoices.includes(randomUpgrade)) {
        upgradeChoices.push(randomUpgrade);
      }
    }
  }

  function applyUpgrade(upgradeType) {
    switch(upgradeType) {
      case 'health':
        player.maxHealth += 50;
        player.health = Math.min(player.maxHealth, player.health + 25); // Also heal a bit
        console.log("‚ù§Ô∏è Health boosted! Max HP:", player.maxHealth);
        break;
      case 'speed':
        player.speed += 1;
        console.log("üèÉ Speed boosted! Speed:", player.speed);
        break;
      case 'damage':
        player.damageUpgradesCount += 1; // Increment counter
        player.attackDamage += 8; // Increase from +5 to +8 for more impact
        console.log("‚öîÔ∏è Damage boosted! Damage:", player.attackDamage);
        break;
      case 'multishot':
        player.multishot += 1;
        // Remove other shot types for balance
        player.hasHoming = false;
        player.hasLaser = false;
        console.log("üéØ Multishot upgraded! Bullets:", player.multishot);
        break;
      case 'homing':
        player.hasHoming = true;
        // Remove other shot types for balance
        player.hasLaser = false;
        console.log("üéØ Homing missiles unlocked!");
        break;
      case 'laser':
        player.hasLaser = true;
        // Remove other shot types for balance
        player.hasHoming = false;
        console.log("‚ö° Piercing laser unlocked!");
        break;
      case 'dashCooldown':
        player.dashCooldown = Math.max(300, player.dashCooldown - 150);
        console.log("üèÉ‚Äç‚ôÇÔ∏è Dash improved! Cooldown:", player.dashCooldown);
        break;
      case 'attackSpeed':
        player.attackDuration = Math.max(50, player.attackDuration - 20);
        console.log("‚ö° Attack speed boosted! Rate:", player.attackDuration);
        break;
    }
  }

  function showUpgradeMenu() {
    upgradeMenuActive = true;
    gameRunning = false; // Pause game
    generateUpgradeChoices();
    renderUpgradeMenu();
  }

  function hideUpgradeMenu() {
    upgradeMenuActive = false;
    gameRunning = true;
    gameRunning = true;
    requestAnimationFrame(gameLoop);
  }

  function renderUpgradeMenu() {
  if (!upgradeMenuActive) return;
  
  // Create overlay
  const overlay = document.createElement('div');
  overlay.id = 'upgradeMenu';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(44, 62, 80, 0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 50;
    font-family: Arial, sans-serif;
  `;
  
  // Create menu content
  overlay.innerHTML = `
    <div style="background: #34495e; padding: 40px; border-radius: 15px; text-align: center; max-width: 800px;">
      <h1 style="color: #f1c40f; margin-bottom: 30px; font-size: 2.5em;">üèÜ BOSS DEFEATED!</h1>
      <h2 style="color: #ecf0f1; margin-bottom: 40px;">Choose Your Upgrade:</h2>
      
      <div style="display: flex; gap: 30px; justify-content: center;">
        ${upgradeChoices.map((choice, index) => {
          const upgrade = upgradeTypes[choice];
          return `
            <div class="upgrade-choice" data-upgrade="${choice}" style="
              background: ${upgrade.color};
              color: white;
              padding: 30px;
              border-radius: 10px;
              cursor: pointer;
              min-width: 200px;
              border: 3px solid transparent;
              transition: all 0.3s ease;
            ">
              <h3 style="margin: 0 0 15px 0; font-size: 1.4em;">${upgrade.name}</h3>
              <p style="margin: 0; font-size: 1.1em;">${upgrade.desc}</p>
            </div>
          `;
        }).join('')}
      </div>
      
      <p style="color: #bdc3c7; margin-top: 30px; font-size: 1.1em;">Click an upgrade to continue to Stage ${stage + 1}</p>
    </div>
  `;
  
  document.body.appendChild(overlay);
  
  // Add hover effects
  const choices = overlay.querySelectorAll('.upgrade-choice');
  choices.forEach(choice => {
    choice.addEventListener('mouseenter', () => {
      choice.style.border = '3px solid #ecf0f1';
      choice.style.transform = 'scale(1.05)';
    });
    
    choice.addEventListener('mouseleave', () => {
      choice.style.border = '3px solid transparent';
      choice.style.transform = 'scale(1)';
    });
    
    choice.addEventListener('click', () => {
      const upgradeType = choice.getAttribute('data-upgrade');
      selectUpgrade(upgradeType);
    });
  });
}

function selectUpgrade(upgradeType) {
  console.log("DEBUG: Selecting upgrade:", upgradeType);
  applyUpgrade(upgradeType);
  
  // Remove upgrade menu
  const menu = document.getElementById('upgradeMenu');
  if (menu) menu.remove();
  
  console.log("DEBUG: About to hide menu and proceed to stage", stage + 1);
  hideUpgradeMenu();
  
  // Proceed to next stage
  stage++;
  console.log("DEBUG: Stage incremented to", stage);
  
  setTimeout(() => {
    console.log("DEBUG: Spawning stage", stage, "boss");
    spawnStageBoss(stage);
    startSlimeWave(stage);
    console.log("DEBUG: Stage transition complete");
  }, 1000);
}

/* Projectile System */
const projectiles = [];

class Projectile {
  constructor(x, y, dirX, dirY, speed, damage, color = '#ffff00') {
    this.x = x;
    this.y = y;
    this.dirX = dirX;
    this.dirY = dirY;
    this.speed = speed;
    this.damage = damage;
    this.color = color;
    this.size = 4;
    this.life = 2000; // 2 seconds max range
    this.timer = 0;
    this.trail = []; // For visual trail

    // Enhanced properties
    this.piercing = false;
    this.maxPierceHits = 0;
    this.currentPierceHits = 0;
    this.hitTargets = []; // Track what we've already hit
  }
  
  update() {
  // Homing logic (classic shoot-em-up style - no retargeting)
  if (this.homing && this.target && this.lockOnTarget) {
    // Only home if target is still alive and not already hit
    let targetValid = false;
    if (!this.hitTargets.includes(this.target)) {
      if (this.target === bossSlime && !bossSlime.defeated) {
        targetValid = true;
      } else if (slimes.includes(this.target)) {
        targetValid = true;
      }
    }
    
    // If target is invalid, missile continues in straight line (classic behavior)
    if (targetValid) {
      const targetX = this.target.x + this.target.width/2;
      const targetY = this.target.y + this.target.height/2;
      const dx = targetX - this.x;
      const dy = targetY - this.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      
      if (dist > 10) {
        const turnSpeed = 0.35;
        const targetDirX = dx / dist;
        const targetDirY = dy / dist;
        
        this.dirX += (targetDirX - this.dirX) * turnSpeed;
        this.dirY += (targetDirY - this.dirY) * turnSpeed;
        
        const magnitude = Math.sqrt(this.dirX*this.dirX + this.dirY*this.dirY);
        if (magnitude > 0) {
          this.dirX /= magnitude;
          this.dirY /= magnitude;
        }
      }
    }
    // If target dies/invalid, missile just continues straight - no retargeting
  }

  
  // Movement
  this.x += this.dirX * this.speed;
  this.y += this.dirY * this.speed;
  
  // Add trail point
  this.trail.push({x: this.x, y: this.y, life: 100});
  if (this.trail.length > 8) this.trail.shift();
  
  // Update trail
  for (let i = this.trail.length - 1; i >= 0; i--) {
    this.trail[i].life -= 16;
    if (this.trail[i].life <= 0) this.trail.splice(i, 1);
  }
  
  // Life timer
  this.timer += 16;
  
  // Check bounds
  if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
    return true;
  }
  
  return this.timer >= this.life;
}

  render() {
    // Draw trail
    for (let i = 0; i < this.trail.length; i++) {
      const t = this.trail[i];
      const alpha = t.life / 100;
      const size = this.size * alpha;
      
      ctx.save();
      ctx.globalAlpha = alpha * 0.6;
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(t.x, t.y, size, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    
    // Draw projectile
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
    
    // Glow effect
    ctx.shadowColor = this.color;
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  findNewTarget() {
    let newTarget = null;
    let minDist = Infinity;
    
    // Check slimes
    slimes.forEach(slime => {
      if (!this.hitTargets.includes(slime)) {
        const dx = slime.x - this.x;
        const dy = slime.y - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < minDist) {
          minDist = dist;
          newTarget = slime;
        }
      }
    });
    
    // Check boss
    if (bossSlime && !bossSlime.defeated && !this.hitTargets.includes(bossSlime)) {
      const dx = bossSlime.x - this.x;
      const dy = bossSlime.y - this.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < minDist) {
        newTarget = bossSlime;
      }
    }
    
    return newTarget;
  }
}

/* Message queue (same as yours) */
const messageQueue = [];
function showMessage(msg, color="#fff", duration=2200){
  messageQueue.push({msg,color,time:Date.now(),duration});
  renderMessageLog();
}
function renderMessageLog(){
  const now=Date.now();
  const visible = messageQueue.filter(m => now - m.time < m.duration);
  const html = visible.map(m=>`<div style="margin:2px 0;color:${m.color};font-size:20px;text-shadow:1px 1px 4px #222;">${m.msg}</div>`).join('');
  document.getElementById('messageLog').innerHTML = html;
  while(messageQueue.length && now - messageQueue[0].time > messageQueue[0].duration) messageQueue.shift();
}

/* ---------- Player definition (kept same fields) ---------- */
const player = {
  x: canvas.width/2, y: canvas.height/2, width:30, height:30,
  color:'#e74c3c',
  speed:6,
  maxHealth:500, health:500,
  invulnerable:false, invulnerabilityTime:500, invulnerabilityTimer:0,
  isDashing:false, dashSpeed:20, dashDuration:150, dashCooldown:700, dashTimer:0, dashCooldownTimer:0, dashDirection:{x:0,y:0}, dashTrail:[],
  isMoving:false, direction:{x:0,y:0},
  isAttacking:false, attackRange:150, attackAngle:45, attackDirection:{x:1,y:0}, attackCooldown:0, attackDuration:100, attackDamage:10, damageUpgradesCount: 0,

  // Power-up properties (combo system)
  multishot: 1,
  hasHoming: false,    // Boolean flag instead of shots count
  hasLaser: false,     // Boolean flag instead of shots count
};

/* ---------- Entities ---------- */
const slimes = [];
const drops = [];
let bossSlime = null;

/* Swarm System */
let waveActive = false;
let waveTimer = 0;
let waveSpawnRate = 2000; // milliseconds between spawns
let maxSlimes = 50; // cap untuk performance
let slimeSpawnRate = 1; // slimes per spawn burst

let totalWaveSlimes = 0;
let maxWaveSlimes = 0;

function startSlimeWave(stage) {
  waveActive = true;
  waveTimer = 0;
  totalWaveSlimes = 0; // Reset counter
  
  // Reduced wave sizes per stage - was 6 + (stage * 3)
  maxWaveSlimes = 4 + (stage * 2); // Stage 1: 6, Stage 2: 8, Stage 3: 10, Stage 4: 12
  waveSpawnRate = Math.max(2000, 4000 - (stage * 400)); // Keep spawn timing same
  slimeSpawnRate = 1; // Always 1 per spawn for better pacing
  
  console.log(`üåä WAVE ${stage}! Total slimes: ${maxWaveSlimes}, Rate: ${waveSpawnRate}ms`);
  showMessage(`üåä WAVE ${stage} - ${maxWaveSlimes} SLIMES!`, "#e74c3c");
}

function updateSlimeWave() {
  if (!waveActive) return;
  
  waveTimer += 16;
  
  // Spawn if timer ready and haven't reached wave limit
  if (waveTimer >= waveSpawnRate && totalWaveSlimes < maxWaveSlimes) {
    waveTimer = 0;
    spawnRandomSlime();
    totalWaveSlimes++;
    
    // End wave when all slimes spawned
    if (totalWaveSlimes >= maxWaveSlimes) {
      waveActive = false;
      console.log(`‚úÖ Wave ${stage} complete! ${maxWaveSlimes} slimes spawned`);
    }
  }
}

function spawnRandomSlime() {
  // Spawn at random edge of screen
  let x, y;
  const edge = Math.floor(Math.random() * 4);
  
  switch(edge) {
    case 0: // Top
      x = Math.random() * canvas.width;
      y = -30;
      break;
    case 1: // Right  
      x = canvas.width + 30;
      y = Math.random() * canvas.height;
      break;
    case 2: // Bottom
      x = Math.random() * canvas.width;
      y = canvas.height + 30;
      break;
    case 3: // Left
      x = -30;
      y = Math.random() * canvas.height;
      break;
  }
  
  slimes.push(new Slime(x, y));
}

/* ---------- Utility helpers ---------- */
function clamp(v,min,max){return Math.max(min,Math.min(max,v));}
function distance(ax,ay,bx,by){const dx=ax-bx,dy=ay-by; return Math.sqrt(dx*dx+dy*dy);}
function randomInRange(min,max){return Math.random()*(max-min)+min;}
function spawnPositionAwayFromPlayer(minDist=120){
  let x,y,safe=false;
  while(!safe){
    x = Math.random()*(canvas.width-100);
    y = Math.random()*(canvas.height-100);
    const dx = (player.x + player.width/2) - (x + 30);
    const dy = (player.y + player.height/2) - (y + 30);
    if (Math.sqrt(dx*dx + dy*dy) > minDist) safe=true;
  }
  return {x,y};
}

/* ---------- Drop class (unchanged visuals/behavior) ---------- */
// class Drop {
//   constructor(x, y, type = null) {
//     this.x = x;
//     this.y = y;
//     this.width = 12;
//     this.height = 12;
//     this.type = type || this.getRandomType();
//     this.color = this.getColorForType(this.type);
//     this.bounceY = 0;
//     this.bounceSpeed = 2;
//     this.collected = false;
//     this.glowEffect = 0;
//   }
  
//   getRandomType() {
//     const types = ['health', 'speed', 'damage', 'dash', 'multishot', 'homing', 'laser'];
//     return types[Math.floor(Math.random() * types.length)];
//   }
  
//   getColorForType(type) {
//     const colors = {
//       health: '#e74c3c',     // Red - Health boost
//       speed: '#2ecc71',      // Green - Speed boost  
//       damage: '#f39c12',     // Orange - Damage boost
//       dash: '#3498db',       // Blue - Dash upgrade
//       multishot: '#9b59b6',  // Purple - Multi projectiles
//       homing: '#1abc9c',     // Teal - Homing missiles
//       laser: '#f1c40f'       // Yellow - Laser beam
//     };
//     return colors[type];
//   }
  
//   update() {
//     this.bounceY += this.bounceSpeed;
//     if (this.bounceY > 10 || this.bounceY < -10) this.bounceSpeed *= -1;
//     this.glowEffect += 0.1;
    
//     const dx = (player.x + player.width/2) - (this.x + this.width/2);
//     const dy = (player.y + player.height/2) - (this.y + this.height/2);
//     const distance = Math.sqrt(dx * dx + dy * dy);
    
//     if (distance < 25) {
//       this.collected = true;
//       this.applyPowerUp();
//       return true;
//     }
//     return false;
//   }
  
//   applyPowerUp() {
//     console.log("üéØ DROP TYPE:", this.type);
//     switch(this.type) {
//       case 'health':
//         player.health = Math.min(player.maxHealth, player.health + 50);
//         console.log("‚ù§Ô∏è Health restored! HP: " + player.health);
//         break;
//       case 'speed':
//         player.speed += 1;
//         console.log("üèÉ Speed boost! Speed: " + player.speed);
//         break;
//       case 'damage':
//         player.attackDamage += 5;
//         console.log("‚öîÔ∏è Damage boost! Damage: " + player.attackDamage);
//         break;
//       case 'dash':
//         player.dashCooldown = Math.max(200, player.dashCooldown - 100);
//         player.dashDuration += 20;
//         console.log("üèÉ‚Äç‚ôÇÔ∏è Dash upgraded! Cooldown: " + player.dashCooldown);
//         break;
//       case 'multishot':
//         player.multishot = (player.multishot || 1) + 1;
//         console.log("üéØ Multishot! Bullets: " + player.multishot);
//         break;
//       case 'homing':
//         player.hasHoming = true;
//         console.log("üéØ HOMING added to arsenal! Multishot + Homing combo!");
//         break;
//       case 'laser':
//         player.hasLaser = true;
//         console.log("‚ö° LASER added to arsenal! All weapons combo!");
//         break;
//     }
//   }
  
//   render() {
//     ctx.shadowColor = this.color;
//     ctx.shadowBlur = 10 + Math.sin(this.glowEffect) * 5;
    
//     ctx.fillStyle = this.color;
//     ctx.fillRect(this.x, this.y + this.bounceY, this.width, this.height);
    
//     ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
//     ctx.fillRect(this.x + 2, this.y + this.bounceY + 2, this.width - 4, this.height - 4);
    
//     // Draw power-up icon
//     ctx.fillStyle = '#fff';
//     ctx.font = '8px monospace';
//     ctx.textAlign = 'center';
//     ctx.fillText(this.getIconForType(this.type), this.x + this.width/2, this.y + this.bounceY + 8);
    
//     ctx.shadowBlur = 0;
//   }
  
//   getIconForType(type) {
//     const icons = {
//       health: '+',
//       speed: '¬ª',
//       damage: '!',
//       dash: '~',
//       multishot: '‚â°',
//       homing: '‚óã',
//       laser: '|'
//     };
//     return icons[type];
//   }
// }

/* ---------- Slime class (kept behavior) ---------- */
class Slime {
  constructor(x,y){
    this.x=x; this.y=y; this.width=25; this.height=25; this.color='#3498db'; this.speed=1.5;
    this.maxHealth=150; this.health=150;
    this.hasShield=true; this.shieldHits=2; this.maxShieldHits=2;
    this.attackDamage=50; this.attackRange=20; this.attackCooldown=2000; this.attackTimer=0;
    this.takingDamage=false; this.damageFlashTimer=0; this.target=player; this.lastShieldReset=Date.now();
  }
  update(){
    if(this.attackTimer>0) this.attackTimer -= 16;
    if(this.damageFlashTimer>0) this.damageFlashTimer -= 16;
    if(this.damageFlashTimer<=0) this.takingDamage=false;
    if(!this.hasShield && Date.now() - this.lastShieldReset > 5000){
      if(Math.random() < 0.3){ this.hasShield=true; this.shieldHits=this.maxShieldHits; this.lastShieldReset=Date.now(); console.log("üõ°Ô∏è Slime shield regenerated!"); }
    }
    const dx=this.target.x - this.x, dy=this.target.y - this.y, dist=Math.sqrt(dx*dx+dy*dy);
    if(dist > this.attackRange && dist > 0){ this.x += (dx/dist)*this.speed; this.y += (dy/dist)*this.speed; }
    if(dist <= this.attackRange && this.attackTimer <= 0) this.attackPlayer();
    this.x = clamp(this.x, 0, canvas.width - this.width); this.y = clamp(this.y, 0, canvas.height - this.height);
  }
  attackPlayer(){
    if(player.isDashing || player.invulnerable) return;
    this.attackTimer = this.attackCooldown;
    player.health -= this.attackDamage;
    startScreenShake(12, 250);
    createDamageNumber(player.x + player.width/2, player.y, this.attackDamage, '#ff0000');
    startHitStop(80);
    createBloodSplash(player.x + player.width/2, player.y + player.height/2, 6);
    player.invulnerable = true; player.invulnerabilityTimer = player.invulnerabilityTime;
    console.log(`üëæ Slime attacks! Player HP: ${player.health}`);
    if(player.health <= 0){ player.health = 0; showMessage("üíÄ HUNTER DOWN!", "#e74c3c"); }
  }
  takeDamage(dmg){
    if(this.hasShield){ this.shieldHits--; console.log(`üõ°Ô∏è Shield hit! Remaining: ${this.shieldHits}`); if(this.shieldHits<=0){ this.hasShield=false; console.log("üî• Shield broken!"); } }
    else { this.health -= dmg; console.log(`üëæ Slime takes ${dmg} damage! HP: ${this.health}`); }
    this.takingDamage=true; this.damageFlashTimer=200;
    return this.health <= 0;
  }
  render(){
    let renderColor = this.takingDamage ? '#e74c3c' : (this.hasShield ? '#3498db' : '#2ecc71');
    ctx.fillStyle = renderColor; ctx.fillRect(this.x,this.y,this.width,this.height);
    ctx.strokeStyle = this.hasShield ? '#2980b9' : '#27ae60'; ctx.lineWidth = 2; ctx.strokeRect(this.x,this.y,this.width,this.height);
    if(this.hasShield){ ctx.fillStyle='rgba(255,255,255,0.4)'; ctx.fillRect(this.x-2,this.y-2,this.width+4,this.height+4); ctx.fillStyle='#ecf0f1'; ctx.font='12px monospace'; ctx.textAlign='center'; ctx.fillText(this.shieldHits.toString(), this.x+this.width/2, this.y-8); }
    this.drawHealthBar();
    if(this.attackTimer <= 100){ ctx.strokeStyle='#e74c3c'; ctx.lineWidth=2; ctx.globalAlpha=0.5; ctx.beginPath(); ctx.arc(this.x+this.width/2,this.y+this.height/2,this.attackRange,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1; }
  }
  drawHealthBar(){
    const barWidth=30, barHeight=4, barX=this.x, barY=this.y-5;
    ctx.fillStyle='#2c3e50'; ctx.fillRect(barX,barY,barWidth,barHeight);
    const hpPercent = this.health / this.maxHealth;
    ctx.fillStyle = hpPercent > 0.5 ? '#2ecc71' : hpPercent > 0.25 ? '#f39c12' : '#e74c3c';
    ctx.fillRect(barX,barY,barWidth*hpPercent,barHeight);
    if(this.hasShield){ ctx.fillStyle='rgba(255,255,255,0.35)'; ctx.fillRect(barX,barY,barWidth,barHeight); }
    ctx.strokeStyle='#ecf0f1'; ctx.lineWidth=1; ctx.strokeRect(barX,barY,barWidth,barHeight);
  }
}

/* ---------- Boss class (kept behavior; minor structure cleanup) ---------- */
class BossSlime {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.width = 60;
    this.height = 60;
    this.color = '#8e44ad';

    // Movement
    this.baseSpeed = 1.5;
    this.speed = this.baseSpeed;

    // Health & Shield
    this.maxHealth = 500;
    this.health = 500;
    this.hasShield = true;
    this.shieldHits = 10;
    this.maxShieldHits = 20;

    // Attack
    this.attackDamage = 100;
    this.attackRange = 50;
    this.attackCooldown = 1200;
    this.attackTimer = 0;

    // Charge system (will be adjusted per stage)
    this.chargeTimer = 0;
    this.chargeCooldown = 6000; // Base cooldown
    this.chargeSpeed = 4;

    this.chargeDuration = 2000;
    this.currentChargeTime = 0;

    this.isTelegraphing = false;
    this.telegraphTime = 800; // Base telegraph time
    this.telegraphTimer = 0;

    this.isCharging = false;

    // Misc
    this.takingDamage = false;
    this.damageFlashTimer = 0;
    this.intimidationAura = 0;
    this.target = player;
    this.lastShieldReset = Date.now();
    this.defeated = false;

    // Aerial Pound Attack (unlocked stage 2+)
    this.hasAerialPound = false;
    this.isAirborne = false;
    this.aerialPoundTimer = 0;
    this.aerialPoundCooldown = 8000; // 8 seconds between aerial attacks
    this.poundTargetX = 0;
    this.poundTargetY = 0;
    this.airTime = 0;
    this.poundDuration = 1500; // Time in air before landing
    this.warningRadius = 80; // Warning circle radius
  }

  update() {
    if (this.defeated) return;

    // timers
    if (this.attackTimer > 0) this.attackTimer -= 16;
    if (this.damageFlashTimer > 0) this.damageFlashTimer -= 16;
    if (this.chargeTimer > 0) this.chargeTimer -= 16;
    if (this.damageFlashTimer <= 0) this.takingDamage = false;
    this.intimidationAura += 0.05;

    // shield regen
    if (!this.hasShield && Date.now() - this.lastShieldReset > 8000) {
      if (Math.random() < 0.2) {
        this.hasShield = true;
        this.shieldHits = this.maxShieldHits;
        this.lastShieldReset = Date.now();
        console.log("üõ°Ô∏è BOSS SHIELD REGENERATED!");
      }
    }

    const dx = this.target.x - this.x;
    const dy = this.target.y - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    // Aerial Pound Attack (Stage 2+)
    if (this.hasAerialPound) {
      if (this.aerialPoundTimer > 0) this.aerialPoundTimer -= 16;
      
      // Trigger aerial pound
      if (this.aerialPoundTimer <= 0 && !this.isAirborne && !this.isTelegraphing && !this.isCharging && dist > 150) {
        this.startAerialPound();
      }
      
      // Handle airborne state
      if (this.isAirborne) {
        this.airTime += 16;
        if (this.airTime >= this.poundDuration) {
          this.landAerialPound();
        }
        return; // Skip normal movement while airborne
      }
  }

    // Trigger telegraph (warning) ‚Üí lalu charge
    if (this.chargeTimer <= 0 && dist > 100 && !this.isTelegraphing && !this.isCharging) {
      this.isTelegraphing = true;
      this.telegraphTimer = this.telegraphTime;
      this.chargeTimer = this.chargeCooldown;
      showMessage("‚ö†Ô∏è BOSS is preparing to CHARGE!", "#f1c40f");
    }

    // Telegraph phase
    if (this.isTelegraphing) {
      this.telegraphTimer -= 16;
      if (this.telegraphTimer <= 0) {
        this.isTelegraphing = false;
        this.isCharging = true;
        this.currentChargeTime = 0; // mulai hitung durasi charge
        showMessage("üíÄ BOSS CHARGE ATTACK!", "#c0392b");
      }
      return; // Boss diem waktu warning
    }

    // Charge phase
    if (this.isCharging) {
      this.currentChargeTime += 16; // üî• increment durasi

      this.x += (dx / dist) * this.chargeSpeed;
      this.y += (dy / dist) * this.chargeSpeed;

      if (dist < 50 || this.currentChargeTime >= this.chargeDuration) {
        // üî• stop kalau kena player atau durasi habis
        this.isCharging = false;
        this.speed = this.baseSpeed;
      }
    } else if (dist > this.attackRange && dist > 0) {
      // Normal move
      this.x += (dx / dist) * this.speed;
      this.y += (dy / dist) * this.speed;
    }

    // Attack if in range
    if (dist <= this.attackRange && this.attackTimer <= 0) this.attackPlayer();

    // Clamp posisi boss biar ga keluar canvas
    this.x = clamp(this.x, 0, canvas.width - this.width);
    this.y = clamp(this.y, 0, canvas.height - this.height);
  }

  startAerialPound() {
  this.isAirborne = true;
  this.airTime = 0;
  this.aerialPoundTimer = this.aerialPoundCooldown;
  
  // Target player's current position
  this.poundTargetX = this.target.x + this.target.width/2;
  this.poundTargetY = this.target.y + this.target.height/2;
  
  showMessage("‚ö†Ô∏è BOSS AERIAL ATTACK!", "#f39c12");
  startScreenShake(5, 300);
  console.log("‚úàÔ∏è BOSS GOES AIRBORNE!");
}

landAerialPound() {
  this.isAirborne = false;
  this.x = this.poundTargetX - this.width/2;
  this.y = this.poundTargetY - this.height/2;
  
  // Clamp to bounds
  this.x = clamp(this.x, 0, canvas.width - this.width);
  this.y = clamp(this.y, 0, canvas.height - this.height);
  
  // Check if player is in damage radius
  const dx = (this.target.x + this.target.width/2) - this.poundTargetX;
  const dy = (this.target.y + this.target.height/2) - this.poundTargetY;
  const distance = Math.sqrt(dx*dx + dy*dy);
  
  if (distance <= this.warningRadius && !this.target.isDashing && !this.target.invulnerable) {
    this.target.health -= this.attackDamage * 1.5; // Extra damage for aerial pound
    createBloodSplash(this.target.x + this.target.width/2, this.target.y + this.target.height/2, 15);
    createDamageNumber(this.target.x + this.target.width/2, this.target.y, this.attackDamage * 1.5, '#ff0000');
    this.target.invulnerable = true;
    this.target.invulnerabilityTimer = this.target.invulnerabilityTime;
  }
  
  // Impact effects
  startScreenShake(15, 400);
  createImpactSparks(this.poundTargetX, this.poundTargetY, 20);
  showMessage("üí• GROUND POUND!", "#c0392b");
  console.log("üí• BOSS LANDS WITH GROUND POUND!");
}

  attackPlayer() {
    if (player.isDashing || player.invulnerable) return;
    this.attackTimer = this.attackCooldown;
    player.health -= this.attackDamage;
    startScreenShake(18, 350);
    createDamageNumber(player.x + player.width/2, player.y, this.attackDamage, '#ff0000');
    startHitStop(80);
    createBloodSplash(player.x + player.width/2, player.y + player.height/2, 12);
    player.invulnerable = true;
    player.invulnerabilityTimer = player.invulnerabilityTime;
    console.log(`üíÄ BOSS ATTACKS! Player HP: ${player.health}`);
    if (player.health <= 0) {
      player.health = 0;
      console.log("üíÄ HUNTER DOWN BY BOSS!");
    }
  }

  takeDamage(damage) {
    if (this.hasShield) {
      this.shieldHits--;
      console.log(`üõ°Ô∏è BOSS SHIELD HIT! Remaining: ${this.shieldHits}`);
      if (this.shieldHits <= 0) {
        this.hasShield = false;
        this.lastShieldReset = Date.now();
        console.log("üî• BOSS SHIELD BROKEN!");
      }
    } else {
      this.health -= damage;
      console.log(`üíÄ BOSS takes ${damage} damage! HP: ${this.health}`);
    }

    this.takingDamage = true;
    this.damageFlashTimer = 300;

    if (this.health <= 0) {
      this.defeated = true;
      // this.dropLoot();
      console.log("üèÜ BOSS DEFEATED! LOOT INCOMING!");
      return true;
    }
    return false;
  }

  // dropLoot() {
  //   const dropCount = Math.floor(Math.random() * 4) + 1;
  //   for (let i = 0; i < dropCount; i++) {
  //     const angle = (Math.PI * 2 * i) / dropCount;
  //     const distance = 40;
  //     const dropX = this.x + this.width / 2 + Math.cos(angle) * distance;
  //     const dropY = this.y + this.height / 2 + Math.sin(angle) * distance;
  //     drops.push(new Drop(dropX - 6, dropY - 6));
  //   }
  // }

  render() {
    if (this.defeated) return;

    // aura ungu
    ctx.strokeStyle = `rgba(142,68,173, ${0.3 + Math.sin(this.intimidationAura) * 0.2})`;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(this.x + this.width / 2, this.y + this.height / 2, 80, 0, Math.PI * 2);
    ctx.stroke();

    // warna body
    let renderColor = this.takingDamage
      ? '#e74c3c'
      : (this.isCharging ? '#c0392b' : (this.hasShield ? '#663399' : this.color));
    ctx.fillStyle = renderColor;
    ctx.fillRect(this.x, this.y, this.width, this.height);

    // border
    ctx.strokeStyle = this.hasShield ? '#522d80' : '#7d3c98';
    ctx.lineWidth = 3;
    ctx.strokeRect(this.x, this.y, this.width, this.height);

    // shield overlay
    if (this.hasShield) {
    ctx.fillStyle = '#ecf0f1';
    ctx.font = '14px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(this.shieldHits.toString(), this.x + this.width / 2, this.y - 20);
    }

    // mahkota
    ctx.fillStyle = '#f1c40f';
    ctx.font = '20px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('üëë', this.x + this.width / 2, this.y - 35);

    // HP bar
    this.drawBossHealthBar();

    // Aerial pound warning circle
    if (this.isAirborne) {
      // Draw warning circle at target location
      ctx.strokeStyle = '#f39c12';
      ctx.fillStyle = 'rgba(243, 156, 18, 0.3)';
      ctx.lineWidth = 4;
      ctx.globalAlpha = 0.8;
      
      ctx.beginPath();
      ctx.arc(this.poundTargetX, this.poundTargetY, this.warningRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // Pulsing effect
      const pulseRadius = this.warningRadius + Math.sin(this.airTime * 0.01) * 15;
      ctx.beginPath();
      ctx.arc(this.poundTargetX, this.poundTargetY, pulseRadius, 0, Math.PI * 2);
      ctx.stroke();
      
      ctx.globalAlpha = 1;
      
      // Don't render boss body while airborne
      return;
    }

    // warning merah pas boss attack normal
    if (this.attackTimer <= 200) {
      ctx.strokeStyle = '#e74c3c';
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.attackRange, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // warning kuning (telegraph)
    if (this.isTelegraphing) {
      ctx.strokeStyle = '#f1c40f';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(this.x + this.width / 2, this.y + this.height / 2, 70, 0, Math.PI * 2);
      ctx.stroke();
    }

    // garis merah arah charge
    if (this.isCharging) {
      let dx = player.x + player.width / 2 - (this.x + this.width / 2);
      let dy = player.y + player.height / 2 - (this.y + this.height / 2);
      let dist = Math.sqrt(dx * dx + dy * dy) || 1;
      ctx.strokeStyle = 'rgba(192,57,43,0.5)';
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.moveTo(this.x + this.width / 2, this.y + this.height / 2);
      ctx.lineTo(this.x + this.width / 2 - (dx / dist) * 40, this.y + this.height / 2 - (dy / dist) * 40);
      ctx.stroke();
    }
  }

  drawBossHealthBar() {
    const barWidth = 80, barHeight = 8;
    const barX = this.x - 10, barY = this.y - 5;
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(barX, barY, barWidth, barHeight);

    const healthPercent = this.health / this.maxHealth;
    ctx.fillStyle =
      healthPercent > 0.6 ? '#8e44ad' :
      healthPercent > 0.3 ? '#e67e22' : '#e74c3c';
    ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);

    if (this.hasShield) {
      ctx.fillStyle = 'rgba(255,255,255,0.35)';
      ctx.fillRect(barX, barY, barWidth, barHeight);
    }

    ctx.strokeStyle = '#f1c40f';
    ctx.lineWidth = 2;
    ctx.strokeRect(barX, barY, barWidth, barHeight);

    ctx.fillStyle = '#ecf0f1';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`BOSS: ${this.health}/${this.maxHealth}`, this.x + this.width / 2, barY - 5);
  }
}

/* ---------- Spawn / init (kept same behavior) ---------- */
function spawnSlimes(){
  scaleStatsForStage(stage);
  slimes.length = 0;
  
  // Start with just a few slimes, then activate swarm
  slimes.push(new Slime(100,100));
  slimes.push(new Slime(canvas.width - 150, canvas.height - 150));
  
  // Start swarm wave
  startSlimeWave(stage);
  
  const pos = spawnPositionAwayFromPlayer(120);
  bossSlime = new BossSlime(pos.x, pos.y);
  console.log("üëë BOSS SLIME HAS APPEARED!");
}

/* ---------- Input Handling (fixed duplicate space case & debounce) ---------- */
const keys = { w:false,a:false,s:false,d:false,up:false,down:false,left:false,right:false,space:false };
const mouse = { x:0,y:0,isPressed:false,isHeld:false };
let dashKeyDown = false;

function getMousePos(e){
  const rect = canvas.getBoundingClientRect();
  return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

document.addEventListener('keydown', (e) => {
  const k = e.key.toLowerCase();
  if(k === 'w') keys.w = true;
  if(k === 'a') keys.a = true;
  if(k === 's') keys.s = true;
  if(k === 'd') keys.d = true;
  if(k === 'arrowup') keys.up = true;
  if(k === 'arrowdown') keys.down = true;
  if(k === 'arrowleft') keys.left = true;
  if(k === 'arrowright') keys.right = true;

  // Spacebar for dash (single case only)
  if(e.key === ' '){
    e.preventDefault();
    if(!dashKeyDown && player.dashCooldownTimer <= 0 && !player.isDashing){
      startDash();
    }
    dashKeyDown = true;
    keys.space = true;
  }
});

document.addEventListener('keyup', (e) => {
  const k = e.key.toLowerCase();
  if(k === 'w') keys.w = false;
  if(k === 'a') keys.a = false;
  if(k === 's') keys.s = false;
  if(k === 'd') keys.d = false;
  if(k === 'arrowup') keys.up = false;
  if(k === 'arrowdown') keys.down = false;
  if(k === 'arrowleft') keys.left = false;
  if(k === 'arrowright') keys.right = false;

  if(e.key === ' '){
    dashKeyDown = false;
    keys.space = false;
  }
});

canvas.addEventListener('mousemove', (e) => {
  const p = getMousePos(e);
  mouse.x = p.x; mouse.y = p.y;
});
canvas.addEventListener('mousedown', (e) => { mouse.isPressed = true; mouse.isHeld = true; });
canvas.addEventListener('mouseup', (e) => { mouse.isPressed = false; mouse.isHeld = false; });
canvas.addEventListener('contextmenu', (e) => e.preventDefault());

/* ---------- Dash / Attack logic (kept original functionality) ---------- */
function startDash(){
  player.isDashing = true;
  player.dashTimer = player.dashDuration;
  player.dashCooldownTimer = player.dashCooldown;

  // decide direction: movement > mouse
  let dashDir = {x:0,y:0};
  if(player.isMoving){
    dashDir.x = player.direction.x; dashDir.y = player.direction.y;
  } else {
    const centerX = player.x + player.width/2, centerY = player.y + player.height/2;
    const dx = mouse.x - centerX, dy = mouse.y - centerY, dist = Math.sqrt(dx*dx + dy*dy);
    if(dist > 0){ dashDir.x = dx/dist; dashDir.y = dy/dist; }
  }
  player.dashDirection = dashDir;
  console.log("üèÉ‚Äç‚ôÇÔ∏è DASH! Direction:", dashDir);
}

function startAttack(){
  player.isAttacking = true;
  player.attackCooldown = player.attackDuration;
  
  const pcx = player.x + player.width/2, pcy = player.y + player.height/2;
  const dx = mouse.x - pcx, dy = mouse.y - pcy, dist = Math.sqrt(dx*dx + dy*dy);
  
  if(dist > 0){ 
    player.attackDirection.x = dx/dist; 
    player.attackDirection.y = dy/dist; 
  } else { 
    player.attackDirection = {x:1,y:0}; 
  }
  
// Fire single combined projectile with all abilities
fireMultishot(pcx, pcy, player.attackDirection.x, player.attackDirection.y);
}

function fireMultishot(x, y, dirX, dirY) {
  // Pre-assign targets for homing if we have multishot + homing
  let availableTargets = [];
  if (player.hasHoming) {
    // Collect all available enemies
    slimes.forEach(slime => availableTargets.push(slime));
    if (bossSlime && !bossSlime.defeated) availableTargets.push(bossSlime);
    
    // // Sort by distance for closest-first targeting
    // availableTargets.sort((a, b) => {
    //   const distA = Math.sqrt((a.x - x)**2 + (a.y - y)**2);
    //   const distB = Math.sqrt((b.x - x)**2 + (b.y - y)**2);
    //   return distA - distB;
    // });
  }

  for (let i = 0; i < player.multishot; i++) {
    let shotDirX = dirX, shotDirY = dirY;
    
    if (player.multishot > 1) {
      const spreadAngle = (i - (player.multishot - 1) / 2) * 0.3;
      const cos = Math.cos(spreadAngle), sin = Math.sin(spreadAngle);
      shotDirX = dirX * cos - dirY * sin;
      shotDirY = dirX * sin + dirY * cos;
    }
    
    // Create projectile with combined properties
    let color = '#ffff00';
    let speed = 8;
    let damage = player.attackDamage;
    
    if (player.hasLaser) {
      color = '#00ffff';
      speed = 12;
      damage *= 1.2;
    }
    
    const projectile = new Projectile(x, y, shotDirX, shotDirY, speed, damage, color);
    
    if (player.hasLaser) {
      projectile.piercing = true;
      projectile.maxPierceHits = 3;
    }
    
    if (player.hasHoming && availableTargets.length > 0) {
      projectile.homing = true;
      
      // Find target closest to mouse direction
      let bestTarget = null;
      let bestScore = Infinity;
      
      availableTargets.forEach(enemy => {
        const enemyX = enemy.x + enemy.width/2;
        const enemyY = enemy.y + enemy.height/2;
        
        // Calculate angle difference between mouse direction and enemy direction
        const enemyAngle = Math.atan2(enemyY - y, enemyX - x);
        const mouseAngle = Math.atan2(shotDirY, shotDirX); // Use individual shot direction
        let angleDiff = Math.abs(enemyAngle - mouseAngle);
        if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
        
        // Combine angle difference with distance for better targeting
        const distance = Math.sqrt((enemyX - x)**2 + (enemyY - y)**2);
        const score = angleDiff * 2 + (distance / 200); // Weight angle more than distance
        
        if (score < bestScore) {
          bestScore = score;
          bestTarget = enemy;
        }
      });
      
      projectile.target = bestTarget;
      projectile.lockOnTarget = true;
    }
    
    projectiles.push(projectile);
  }
  
  let abilities = ['Multishot: ' + player.multishot];
  if (player.hasLaser) abilities.push('Piercing');
  if (player.hasHoming) abilities.push('Homing');
  console.log(`üéØ COMBINED SHOT! ${abilities.join(' + ')}`);
}

function findNearestEnemy(x, y) {
  let target = null;
  let minDist = Infinity;
  
  slimes.forEach(slime => {
    const dx = slime.x - x, dy = slime.y - y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < minDist) {
      minDist = dist;
      target = slime;
    }
  });
  
  if (bossSlime && !bossSlime.defeated) {
    const dx = bossSlime.x - x, dy = bossSlime.y - y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < minDist) {
      target = bossSlime;
    }
  }
  
  return target;
}

function fireHomingMissile(x, y) {
  // Find nearest enemy for homing target
  let target = null;
  let minDist = Infinity;
  
  // Check slimes
  slimes.forEach(slime => {
    const dx = slime.x - x, dy = slime.y - y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < minDist) {
      minDist = dist;
      target = slime;
    }
  });
  
  // Check boss
  if (bossSlime && !bossSlime.defeated) {
    const dx = bossSlime.x - x, dy = bossSlime.y - y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < minDist) {
      target = bossSlime;
    }
  }
  
  if (target) {
    const dx = target.x - x, dy = target.y - y, dist = Math.sqrt(dx*dx + dy*dy);
    const projectile = new Projectile(x, y, dx/dist, dy/dist, 12, player.attackDamage * 1.5, '#ff6600');
    projectile.homing = true;
    projectile.target = target;
    projectiles.push(projectile);
    console.log("üéØ HOMING MISSILE FIRED!");
  }
}

function fireLaserBeam(x, y, dirX, dirY) {
  // Create multiple fast projectiles for laser effect
  for (let i = 0; i < 8; i++) {
    const projectile = new Projectile(x, y, dirX, dirY, 20, player.attackDamage * 0.5, '#00ffff');
    projectile.size = 2;
    projectile.life = 500; // Shorter range
    projectiles.push(projectile);
  }
  console.log("‚ö° LASER BEAM FIRED!");
}

function checkProjectileHits() {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const proj = projectiles[i];
    let hit = false;
    
    // Check boss hit
    if (bossSlime && !bossSlime.defeated) {
      const dx = proj.x - (bossSlime.x + bossSlime.width/2);
      const dy = proj.y - (bossSlime.y + bossSlime.height/2);
      const distance = Math.sqrt(dx*dx + dy*dy);
      
      if (distance < bossSlime.width/2 + proj.size && !proj.hitTargets.includes(bossSlime)) {
        createImpactSparks(proj.x, proj.y, 8);
        startScreenShake(4, 150);
        const dead = bossSlime.takeDamage(proj.damage);

        if (dead) {
          console.log("üèÜ BOSS DEFEATED!");
          waveActive = false;
          setTimeout(() => {
            showUpgradeMenu();
          }, 1500);
          
          // Self-destruct homing missiles after killing their target
          if (proj.homing) {
            projectiles.splice(i, 1);
            continue;
          }
        }
        
        if (proj.piercing) {
          proj.hitTargets.push(bossSlime);
          proj.currentPierceHits++;
          hit = proj.currentPierceHits >= proj.maxPierceHits;
        } else {
          projectiles.splice(i, 1); // Remove immediately for non-piercing
          continue; // Now safe to continue since death check is done
        }
      }
    }
    
    // Check normal slimes
    if (!hit) {
      for (let j = slimes.length - 1; j >= 0; j--) {
        const slime = slimes[j];
        const dx = proj.x - (slime.x + slime.width/2);
        const dy = proj.y - (slime.y + slime.height/2);
        const distance = Math.sqrt(dx*dx + dy*dy);
        
        if (distance < slime.width/2 + proj.size && !proj.hitTargets.includes(slime)) {
          createImpactSparks(proj.x, proj.y, 5);
          startScreenShake(3, 120);
          const dead = slime.takeDamage(proj.damage);
          
          if (proj.piercing) {
            proj.hitTargets.push(slime);
            proj.currentPierceHits++;
            if (proj.currentPierceHits >= proj.maxPierceHits) {
              hit = true;
            }
          } else {
            hit = true;
          }
          
          if (dead) {
            slimes.splice(j, 1);
            console.log("üíÄ Slime defeated!");
            setTimeout(() => {
              if (slimes.length < maxSlimes) {
                spawnRandomSlime();
                console.log("üëæ New slime spawned!");
              }
            }, 3000);
          }
          
          
           if (proj.homing) {
          projectiles.splice(projectileIndex, 1); // Use the outer loop index
          break;

          if (!proj.piercing) break;
          }
        }
      }
    }
  }
}

function checkAttackHits(){
  const pcx = player.x + player.width/2, pcy = player.y + player.height/2;

  // Boss first
  if(bossSlime && !bossSlime.defeated){
    const bx = bossSlime.x + bossSlime.width/2, by = bossSlime.y + bossSlime.height/2;
    const dx = bx - pcx, dy = by - pcy, dist = Math.sqrt(dx*dx + dy*dy);
    if(dist <= player.attackRange){
      const angleTo = Math.atan2(dy,dx), atkAngle = Math.atan2(player.attackDirection.y,player.attackDirection.x);
      const halfArc = (player.attackAngle*Math.PI/180)/2;
      let diff = Math.abs(angleTo - atkAngle); if(diff > Math.PI) diff = 2*Math.PI - diff;
      if(diff <= halfArc){
        createImpactSparks(bx, by, 8)
        const dead = bossSlime.takeDamage(player.attackDamage);
        if(dead){
          console.log("üèÜ BOSS DEFEATED! LEGENDARY LOOT!");
          // stage logic preserved (copied behavior, minimal restructure)
          if(stage === 1){
            stage = 2;
            setTimeout(()=>{ spawnStageBoss(2); }, 10000);
          } else {
            stage++;
            setTimeout(()=>{ spawnStageBoss(stage); }, 10000);
          }
        }
      }
    }
  }

  // Normal slimes
  for(let i = slimes.length-1; i>=0; i--){
    const s = slimes[i];
    const sx = s.x + s.width/2, sy = s.y + s.height/2;
    const dx = sx - pcx, dy = sy - pcy, dist = Math.sqrt(dx*dx + dy*dy);
    if(dist <= player.attackRange){
      const angleTo = Math.atan2(dy,dx), atkAngle = Math.atan2(player.attackDirection.y,player.attackDirection.x);
      const halfArc = (player.attackAngle*Math.PI/180)/2;
      let diff = Math.abs(angleTo - atkAngle); if(diff > Math.PI) diff = 2*Math.PI - diff;
      if(diff <= halfArc){
        createImpactSparks(sx, sy, 5);
        const dead = s.takeDamage(player.attackDamage);
        if(dead){
          slimes.splice(i,1);
          console.log("üíÄ Slime defeated!");
          setTimeout(()=>{ slimes.push(new Slime(Math.random()*(canvas.width-50), Math.random()*(canvas.height-50))); console.log("üëæ New slime spawned!"); }, 3000);
        }
      }
    }
  }
}

/* helper used when spawning next stage boss (preserve values you used) */
function spawnStageBoss(stageNum){
  const pos = spawnPositionAwayFromPlayer(120);
  bossSlime = new BossSlime(pos.x, pos.y);

  // Reduced health scaling - was 800 + stageNum*300
  bossSlime.maxHealth = 600 + stageNum*200; // More reasonable: 800, 1000, 1200 instead of 1100, 1400, 1700
  bossSlime.health = bossSlime.maxHealth;
  
  // Progressive scaling untuk handle combo weapons
  bossSlime.maxHealth = 800 + stageNum*300; // Stage 1: 1100 HP instead of 700
  bossSlime.health = bossSlime.maxHealth;
  bossSlime.attackDamage = 80 + stageNum*20;
  bossSlime.shieldHits = bossSlime.maxShieldHits = 8 + stageNum*3; // Stronger shields
  bossSlime.chargeSpeed = 3 + stageNum*0.5;
  bossSlime.speed = 1.5 + stageNum*0.3; // Faster movement
  
  // Unlock new abilities per stage
  if(stageNum >= 2) {
    bossSlime.hasAerialPound = true;
  }
  
  // Color coding per stage
  if(stageNum === 2) bossSlime.color = '#d35400'; // Orange
  else if(stageNum >= 3) bossSlime.color = '#8e44ad'; // Purple

  // Progressive attack speed per stage
  bossSlime.telegraphTime = Math.max(300, 800 - (stageNum * 150)); // Faster telegraph
  bossSlime.chargeCooldown = Math.max(3000, 6000 - (stageNum * 500)); // More frequent attacks
  bossSlime.aerialPoundCooldown = Math.max(4000, 8000 - (stageNum * 600)); // Faster aerial pounds
  bossSlime.poundDuration = Math.max(800, 1500 - (stageNum * 100)); // Less air time

console.log(`‚ö° BOSS TIMING - Telegraph: ${bossSlime.telegraphTime}ms, Charge CD: ${bossSlime.chargeCooldown}ms`);
  
  console.log(`üî• STAGE ${stageNum} BOSS - HP: ${bossSlime.maxHealth}, DMG: ${bossSlime.attackDamage}`);
}

/* ---------- Update & Render ---------- */
function updatePlayer(){
  // timers (kept fixed-step style like your original code: -16)
  if(player.attackCooldown > 0) player.attackCooldown -= 16;
  if(player.dashTimer > 0) player.dashTimer -= 16;
  if(player.dashCooldownTimer > 0) player.dashCooldownTimer -= 16;
  if(player.invulnerabilityTimer > 0) player.invulnerabilityTimer -= 16;

  player.attackCooldown = Math.max(0,player.attackCooldown);
  player.dashTimer = Math.max(0,player.dashTimer);
  player.dashCooldownTimer = Math.max(0,player.dashCooldownTimer);
  player.invulnerabilityTimer = Math.max(0,player.invulnerabilityTimer);

  if(player.invulnerabilityTimer <= 0) player.invulnerable = false;
  if(player.dashTimer <= 0) player.isDashing = false;

  // Attack input
  if(mouse.isHeld && player.attackCooldown <= 0 && !player.isDashing) startAttack();
  else if(!mouse.isHeld) player.isAttacking = false;

  // Movement input
  player.isMoving = false; player.direction.x = 0; player.direction.y = 0;
  if(keys.w || keys.up){ player.direction.y = -1; player.isMoving = true; }
  if(keys.s || keys.down){ player.direction.y = 1; player.isMoving = true; }
  if(keys.a || keys.left){ player.direction.x = -1; player.isMoving = true; }
  if(keys.d || keys.right){ player.direction.x = 1; player.isMoving = true; }
  if(player.direction.x !== 0 && player.direction.y !== 0){ player.direction.x *= 0.7071; player.direction.y *= 0.7071; }

  // Movement apply
  let moveSpeed = player.speed, moveDir = player.direction;
  if(player.isDashing){ moveSpeed = player.dashSpeed; moveDir = player.dashDirection;
    player.dashTrail.push({ x: player.x + player.width/2, y: player.y + player.height/2, life:200 });
    if(player.dashTrail.length > 10) player.dashTrail.shift();
  }
  const newX = player.x + (moveDir.x * moveSpeed);
  const newY = player.y + (moveDir.y * moveSpeed);
  if(newX >= 0 && newX <= canvas.width - player.width) player.x = newX;
  if(newY >= 0 && newY <= canvas.height - player.height) player.y = newY;

  for(let i = player.dashTrail.length-1; i >= 0; i--){
    player.dashTrail[i].life -= 16;
    if(player.dashTrail[i].life <= 0) player.dashTrail.splice(i,1);
  }
}

function updateSlimes(){
  slimes.forEach(s=>s.update());
  if(bossSlime && !bossSlime.defeated) bossSlime.update();
}

function checkGameOver(){
  if(player.health <= 0 && !gameOver){
    gameOver = true; gameRunning = false; document.getElementById('gameOverOverlay').style.display = 'flex';
  }
}

function render(){
   // Apply screen shake offset
  ctx.save();
  ctx.translate(screenShake.offsetX, screenShake.offsetY);
  
  // clear
  ctx.fillStyle = '#27ae60'; 
  ctx.fillRect(-screenShake.offsetX, -screenShake.offsetY, canvas.width, canvas.height);

  // grid
  ctx.strokeStyle = '#2ecc71'; ctx.lineWidth = 1; ctx.globalAlpha = 0.3;
  for(let x=0;x<canvas.width;x+=50){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
  for(let y=0;y<canvas.height;y+=50){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }
  ctx.globalAlpha = 1;

  // dash trail
  for(let i=0;i<player.dashTrail.length;i++){
    const t = player.dashTrail[i]; const alpha = t.life / 200;
    ctx.fillStyle = `rgba(243,156,18,${alpha})`; ctx.beginPath(); ctx.arc(t.x,t.y,8*alpha,0,Math.PI*2); ctx.fill();
  }

  // drops
  for(let i=drops.length-1;i>=0;i--){ const d=drops[i]; if(d.update()) drops.splice(i,1); else d.render(); }

  // slimes
  slimes.forEach(s=>s.render());

  // boss
  if(bossSlime && !bossSlime.defeated) bossSlime.render();

  // player
  let playerVisible = true;
  if(player.invulnerable) playerVisible = Math.floor(gameTime/100) % 2 === 0;
  if(playerVisible){
    let playerColor = player.color;
    if(player.isDashing) playerColor = '#f39c12';
    else if(player.isAttacking) playerColor = '#c0392b';
    ctx.fillStyle = playerColor; ctx.fillRect(player.x,player.y,player.width,player.height);
    ctx.strokeStyle = player.isDashing ? '#e67e22' : '#c0392b'; ctx.lineWidth = 2; ctx.strokeRect(player.x,player.y,player.width,player.height);
  }

  if(player.isAttacking) drawAttackArc();

  if(player.isMoving && !player.isDashing){
    ctx.fillStyle = '#f39c12';
    const cx = player.x + player.width/2, cy = player.y + player.height/2, arrow=20;
    ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx + (player.direction.x*arrow), cy + (player.direction.y*arrow)); ctx.lineWidth = 3; ctx.strokeStyle = '#f39c12'; ctx.stroke();
  }

    // projectiles
  for(let i = projectiles.length - 1; i >= 0; i--) {
    const proj = projectiles[i];
    if(proj.update()) {
      projectiles.splice(i, 1); // Remove expired projectiles
    } else {
      proj.render();
    }
  }

  // particles
  for(let i = particles.length - 1; i >= 0; i--) {
    const particle = particles[i];
    if(particle.update()) {
      particles.splice(i, 1); // Remove dead particles
    } else {
      particle.render();
    }
  }

  // damage numbers
  for(let i = damageNumbers.length - 1; i >= 0; i--) {
    const dmgNum = damageNumbers[i];
    if(dmgNum.update()) {
      damageNumbers.splice(i, 1); // Remove expired numbers
    } else {
      dmgNum.render();
    }
  }

  // cursor
  ctx.fillStyle = '#e67e22'; ctx.beginPath(); ctx.arc(mouse.x,mouse.y,5,0,Math.PI*2); ctx.fill();
  
  // Restore canvas transform
  ctx.restore();
}

/* attack arc visual (kept) */
function drawAttackArc(){
  // const cx = player.x + player.width/2, cy = player.y + player.height/2;
  // const attackAngleRad = Math.atan2(player.attackDirection.y, player.attackDirection.x);
  // const halfArc = (player.attackAngle * Math.PI / 180) / 2;
  // ctx.strokeStyle = '#e74c3c'; ctx.fillStyle = 'rgba(231,76,60,0.3)'; ctx.lineWidth = 3;
  // ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,player.attackRange, attackAngleRad-halfArc, attackAngleRad+halfArc); ctx.closePath(); ctx.fill(); ctx.stroke();
  // ctx.strokeStyle = '#c0392b'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx + (player.attackDirection.x * player.attackRange), cy + (player.attackDirection.y * player.attackRange)); ctx.stroke();
}

/* ---------- UI updates (kept) ---------- */
function updateUI(){
  const healthPercent = player.health / player.maxHealth;
  document.getElementById('playerHealthFill').style.width = (healthPercent*100) + '%';
  document.getElementById('healthText').textContent = `${player.health}/${player.maxHealth}`;
  let dashPercent;
  if(player.dashCooldownTimer > 0) dashPercent = 1 - (player.dashCooldownTimer / player.dashCooldown);
  else dashPercent = 1;
  dashPercent = clamp(dashPercent,0,1);
  document.getElementById('dashCooldownFill').style.width = (dashPercent*100) + '%';
}

/* ---------- Stats text ---------- */
function updateStats(){
  const status = player.isDashing ? "DASHING" : player.isAttacking ? "ATTACKING" : player.invulnerable ? "INVULNERABLE" : "Ready";
  const bossStatus = (bossSlime && !bossSlime.defeated) ? "ALIVE" : "DEFEATED";
  const dropCount = drops.length;
  document.getElementById('gameStats').textContent =
    `Position: (${Math.round(player.x)}, ${Math.round(player.y)}) | Slimes: ${slimes.length} | Boss: ${bossStatus} | Drops: ${dropCount} | Status: ${status} | HP: ${player.health}`;
}

/* ---------- Main loop ---------- */
function gameLoop(){
  if(!gameRunning) {
    console.log("DEBUG: gameLoop stopped, gameRunning is false");
    return;
  }
  
  gameTime += 16;
  updateHitStop();
  
  if (!hitStop.active) {
    updatePlayer();
    updateSlimes();
    checkProjectileHits();
    updateSlimeWave();
  }
  
  updateScreenShake();
  render();
  updateUI(); 
  updateStats(); 
  renderMessageLog();
  checkGameOver();
  
  if(gameRunning) {
    requestAnimationFrame(gameLoop);
  } else {
    console.log("DEBUG: gameRunning became false during loop execution");
  }
}

/* ---------- Scaling & spawn helpers ---------- */
function scaleStatsForStage(s){
  // player.maxHealth = 100 + (s-1)*200; player.health = player.maxHealth;
  player.speed = 6 + (s-1)*0.5; player.attackDamage = 10 + (s-1)*5;
  // Base damage grows by 3 per stage + upgrade bonuses
  const baseDamage = 10 + (s-1)*3;
  const upgradeBonuses = player.damageUpgradesCount * 8;
  player.attackDamage = baseDamage + upgradeBonuses;
  
  console.log(`üìä Stage ${s} damage scaling: Base ${baseDamage} + Upgrades ${upgradeBonuses} = ${player.attackDamage}`);
  if(bossSlime){
    bossSlime.maxHealth = 2000 + (s-1)*500; bossSlime.health = bossSlime.maxHealth;
    bossSlime.attackDamage = 100 + (s-1)*10; bossSlime.speed = 1.5 + (s-1)*0.3; bossSlime.chargeSpeed = 5 + (s-1)*0.5;
    bossSlime.shieldHits = bossSlime.maxShieldHits = 5 + (s-1)*2;
  }
}

/* ---------- Start / restart handlers (kept) ---------- */
document.getElementById('restartBtn').onclick = function(){
  player.x = canvas.width/2; 
  player.y = canvas.height/2; 
  
  // Reset power-ups to base values
  player.multishot = 1;
  player.hasHoming = false;
  player.hasLaser = false;
  player.speed = 6;
  player.attackDamage = 10;
  player.maxHealth = 500;
  player.health = 500;
  player.dashCooldown = 700;
  player.dashDuration = 150;
  player.attackDuration = 100;
  player.damageUpgradesCount = 0;
  
  // Reset game state
  waveActive = false;
  upgradeMenuActive = false;
  
  // Remove upgrade menu if it exists
  const menu = document.getElementById('upgradeMenu');
  if (menu) menu.remove();
  
  // Reset player state
  player.invulnerable = false; 
  player.invulnerabilityTimer = 0; 
  player.isDashing = false; 
  player.dashTimer = 0; 
  player.dashCooldownTimer = 0; 
  player.dashTrail = [];
  player.isAttacking = false; 
  player.attackCooldown = 0; 
  player.attackDirection = {x:1,y:0};
  
  // Reset arrays and game state
  slimes.length = 0; 
  drops.length = 0; 
  bossSlime = null; 
  stage = 1; 
  gameOver = false; 
  gameRunning = true;
  
  document.getElementById('gameOverOverlay').style.display = 'none';
  spawnSlimes(); 
  gameLoop();
};

function spawnSlimes(){
  scaleStatsForStage(stage);
  slimes.length = 0;
  slimes.push(new Slime(100,100));
  slimes.push(new Slime(canvas.width - 150, canvas.height - 150));
  const pos = spawnPositionAwayFromPlayer(120);
  bossSlime = new BossSlime(pos.x, pos.y);
  console.log("üëë BOSS SLIME HAS APPEARED!");
}

/* start button */
document.getElementById('startGameBtn').onclick = function(){
  document.getElementById('menuScreen').style.display = 'none';
  gameRunning = true; gameOver = false; player.health = player.maxHealth;
  player.x = canvas.width/2; player.y = canvas.height/2; slimes.length = 0; drops.length = 0; bossSlime = null; stage = 1;
  spawnSlimes(); gameLoop();
};

/* window load: show menu */
window.onload = function(){ document.getElementById('menuScreen').style.display = 'flex'; gameRunning = false; gameOver = false; };

/* initial logs (kept) */
console.log("üéÆ Monster Hunter Complete - Game Started!");
console.log("üèÉ‚Äç‚ôÇÔ∏è Press Space to dash (I-frames!)");
console.log("‚öîÔ∏è Hold mouse to attack slimes");
console.log("üõ°Ô∏è Blue slimes have shields - hit twice to break!");
console.log("üëë PURPLE BOSS SLIME - multiple shield hits, drops loot!");
</script>
</body>
</html>
